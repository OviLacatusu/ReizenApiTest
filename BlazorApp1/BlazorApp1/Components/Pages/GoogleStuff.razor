@using Microsoft.AspNetCore.Http
@using System.Web
@using Newtonsoft.Json
@using System.Text
@using global::GoogleAccess.Domain.Models
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Authentication
@using System.Text.Json
@using Models
@using Microsoft.AspNetCore.Identity;
@using Data
@using Google.Apis.Gmail.v1.Data
@using BlazorApp1.Components.BootstrapComponents
@using MimeKit

@page "/GoogleAccess"

@rendermode @(new InteractiveServerRenderMode(prerender:false))

@inject IJSRuntime JSRuntime;
@inject SignInManager<ApplicationUser> SignInManager
@inject ILogger<GoogleStuff> _logger;
@inject IHttpClientFactory _factory;
@inject NavigationManager _navManager;
@inject AuthenticationStateProvider _authStateProvider;
@inject IHttpContextAccessor _httpContextAccessor;
@inject UserManager<ApplicationUser> UserManager;
@inject Blazored.SessionStorage.ISessionStorageService _storage;
@inject IOptionsSnapshot<ConfigOptions> _config;
@inject CustomAuthDelegatingHandler _oAuthHttpHandler;

<div class="container">
    <AuthorizeView>
        @if (IsLoggedInWithGoogle(_httpContextAccessor.HttpContext?.User))
        {
            <BootstrapCollapsingElement Title="Google Photos API" OnClickCallback="@(async () =>{await GetPickerSessionAsync();})">
                <ElementBody>
                    <div class="buttonPickerDiv">
                        <div class="col-md-2">
                            @*Closing the picking session window before picking the fotos will have the polling loop run indefinately*@
                            <button class="btn btn-primary" @onclick="@(async()=>await OpenTabAndPollSessionAsync())">Open Picker Session</button>
                        </div>
                    </div>

                    @if (MediaItems?.MediaItems?.Count() > 0)
                    {
                        foreach (var item in MediaItems.MediaItems)
                        {
                            <div class="row">
                                <div class="col-md-2">

                                    <button class="btn btn-link" @onclick="@(async () => await DownloadFotoAsync(item.MediaFile))">@item.MediaFile?.Filename</button>
                                </div>
                            </div>
                        }
                        <div class="buttonDownloadAllDiv">
                            <div class="col-md-2">
                                <button class="btn btn-primary" @onclick="(async () => await DownloadFiles(MediaItems.MediaItems))">Download files</button>
                            </div>
                        </div>
                    } 
                </ElementBody>
            </BootstrapCollapsingElement>

            <BootstrapCollapsingElement Title="Google Gmail API" OnClickCallback="@(async ()=> {await GetMailMessagesAsync();})">
                <ElementBody>
                    @if (IsSuccessfull)
                    {
                        @* <BootstrapTimedErrorBox Error="Message deleted successfully!" TypeBox="BootstrapTimedErrorBox.Type.SUCCESS"></BootstrapTimedErrorBox> *@
                        <div class="alert alert-success">Message deleted successfully</div>
                    }
                    @if (Messages?.Count() > 0) 
                    {
                        @* TO DO: Find a beter way of passing the message ID to the ModalComponent Callback  *@
                        <BootstrapModalComponent @ref="Modal" TypeButton="BootstrapModalComponent.ButtonTypes.DANGER" Message="Are you sure you want to delete? This will permanently delete the message!" Header="Delete message" OnClickCallback="@( async () => { if( !String.IsNullOrEmpty(SelectedMessageId) ){ await DeleteMessageAsync (SelectedMessageId); Modal.Close(); }})"></BootstrapModalComponent> 

                        foreach (var item in Messages)  
                        {  
                            <div class="row">  
                                <div class="col-md-3">  
                                    <p>@item?.Payload?.Headers?.Where(x => x.Name == "From").First()?.Value</p>  
                                </div>
                                <div class="col-lg-6">
                                    <BootstrapModalEmailComponent OnClickCallback="@(async () => {await OnSubjectLinkClickedHandler(item.Id);})" Content="@ContentSelectedEmail" Header="@(@item?.Payload?.Headers?.Where(x => x.Name == "Subject").FirstOrDefault()?.Value)"></BootstrapModalEmailComponent>
                                </div>  
                                <div class="col-md-2">  
                                    <button class="btn btn-link" @onclick="@( async () => { Modal.Open(); SelectedMessageId = item?.Id; })">Delete mail</button>   
                                </div>  
                            </div> 
                        }
                    } 
                    else if (Messages == null)
                    {
                        <div>Fetching messages...</div>
                    }
                </ElementBody>
            </BootstrapCollapsingElement>
        } 
    </AuthorizeView>
    @if (!String.IsNullOrEmpty(Error))
    {
        // Find a beter way of showing login link
        <div class="alert alert-danger">@((MarkupString)Error) </div>
    } 
</div>

@* Suggested way of downloading files < 250 MB in size using JSInterop *@
<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => 
    {
    const arrayBuffer = await contentStreamReference.arrayBuffer();
    const blob = new Blob([arrayBuffer]);
    const url = URL.createObjectURL(blob);

    const anchorElement = document.createElement('a');
    anchorElement.href = url;
    anchorElement.download = fileName ?? '';
    anchorElement.click();
    anchorElement.remove();
    URL.revokeObjectURL(url);
    };
</script>

<style>
    .row:hover
    {
    background-color: lightgray;
    }
</style>

@code
{
    private PickingSession? SessionData { get; set; }

    private ConfigOptions Options => _config.Value;

    private BootstrapModalComponent Modal { get; set; }

    private string? SelectedMessageId { get; set; }

    private string? Error { get; set; }

    private bool IsSuccessfull { get; set; } = false;

    private bool IsLoggedWithGoogle { get; set; } = false;

    private CancellationToken token = new();

    private GPhotosDetailsFiles? MediaItems { get; set; }

    private IEnumerable<Message>? Messages { get; set; }

    private IList<MimeMessage>? MimeMessages { get; set; } = new List<MimeMessage>();

    private string? ContentSelectedEmail { get; set; }

    private bool IsErrorShown = true;

    protected override async Task OnInitializedAsync()
    {
        _logger.LogInformation("-- OnInitialized called --");
        try
        {
            var user = _httpContextAccessor.HttpContext?.User;

            if (IsLoggedInWithGoogle(user))
            {
                IsLoggedWithGoogle = true;
                // await GetMailMessagesAsync();
            }
            else
            {
                Error = "Not authorized. Please log in with Google  <a href='/Account/Login'>Here</a>";
            }
        }
        catch (Exception ex) 
        {
            _logger.LogWarning(ex, "Failed during OnInitialized");
            Error = "Something went wrong.";
        }
    }

    protected override void OnParametersSet()
    {
        _logger.LogInformation("++ OnParametersSet called ++");
    }

    protected override void OnAfterRender(bool firstRender)
    {
        _logger.LogInformation($"** OnAfterRender called with firstrender = {firstRender} **");
    }

    private async Task OnSubjectLinkClickedHandler(string messageId) 
    {
        try
        {
            var message = await GetMessageWithIdAsync(messageId);
            var mime = ParseMimeMessage(message);
            ContentSelectedEmail = mime.HtmlBody;
        }
        catch (Exception ex) 
        {
            Error = "Something went wrong.";
            _logger.LogWarning(ex.Message);
        }
    }

    private bool IsLoggedInWithGoogle(ClaimsPrincipal? user) 
    { 
        return (user?.FindFirst(ClaimTypes.AuthenticationMethod)?.Value?.Contains("google", StringComparison.OrdinalIgnoreCase) == true) ? true : false ;
    }

    private async Task GetMailMessagesAsync()
    {
        try
        {
            var httpClient = _factory.CreateClient ("GoogleAccess");
            httpClient.BaseAddress = new Uri (Options.ApiUrl);

            var result = await HelperRequest.SendGetRequestAndParseJsonAsync<IList<Message>> ("/api/GoogleAccess/GetMessages", httpClient);
            if (result.IsSuccessful)
            {
                Messages = result?.Value;
            }
            else
            {
                Error = result.Error;
                _logger.LogWarning (result.Error);
            }
        }
        catch (Exception ex) 
        {
            Error = "Failed to retrieve mail messages.";
            _logger.LogError (ex, "Error in GetMailMessagesAsync");
        }
    }

    private async Task<Message?> GetMessageWithIdAsync(string messageId) 
    {
        if (String.IsNullOrEmpty (messageId))
        {
            Error = "Invalid message id";
            return null;
        }
        try
        {
            var httpClient = _factory.CreateClient ("GoogleAccess");
            httpClient.BaseAddress = new Uri (Options.ApiUrl);

            var result = await HelperRequest.SendGetRequestAndParseJsonAsync<Message> ($"/api/GoogleAccess/GetMessage/{messageId}", httpClient);
            if (result.IsSuccessful)
            {
                return result?.Value;
            }
            else
            {
                Error = result.Error;
                _logger.LogWarning (result.Error);
            }
        }
        catch (Exception ex)
        {
            Error = "Failed to retrieve message.";
            _logger.LogError (ex, $"Error in GetMessageWithIdAsync for message {messageId}");
        }
        return null;
    }

    private MimeKit.MimeMessage? ParseMimeMessage(Message message)
    {
        try
        {
            var bytes = Microsoft.AspNetCore.WebUtilities.Base64UrlTextEncoder.Decode(message.Raw);
            var parser = new MimeKit.MimeParser(new MemoryStream(bytes), false);

            var result = parser.ParseMessage();
            return result;
        }
        catch (Exception ex) 
        { 
            Error = "Failed to parse message.";
            _logger.LogWarning(ex, "Failed during parsing of mime message");
        }
        return null;
    }

    // Requests a Picker session
    private async Task GetPickerSessionAsync()
    {
        try
        {
            var httpClient = _factory.CreateClient ("GoogleAccess");
            httpClient.BaseAddress = new Uri (Options.ApiUrl);

            var result = await HelperRequest.SendGetRequestAndParseJsonAsync<PickingSession> ("/api/GoogleAccess/GetPickerLink", httpClient);
            if (result.IsSuccessful)
            {
                SessionData = result?.Value;
            }
            else
            {
                Error = result.Error;
                _logger.LogWarning (result.Error);
            }
        }
        catch (Exception ex)
        {
            Error = "Something went wrong.";
            _logger.LogWarning (ex, "Failed to get a Picker session");
        }
    }

    // Opens the Picker session in a new tab and starts a Web API call that polls the session state
    private async Task OpenTabAndPollSessionAsync()
    {
        try
        {
            if (SessionData is not null)
            {
                await JSRuntime.InvokeVoidAsync ("open", $"{SessionData.pickerUri}", "_blank");
                await PollRequestPickerApiAsync (SessionData.id);
            }
        }
        catch (Exception ex) 
        { 
            Error = "Something went wrong.";
            _logger.LogWarning (ex, "Error in OpenTabAndPollSession");
        }
    }

    // Polls the Picker session and returns the details of the picked media files
    private async Task PollRequestPickerApiAsync(string sessionId)
    {
        _logger.LogInformation($"Running PollRequest at {DateTime.UtcNow.ToShortTimeString()}");
        try
        {
            using (var httpClient = _factory.CreateClient ("GoogleAccess"))
            {
                httpClient.BaseAddress = new Uri (Options.ApiUrl);

                var result = await HelperRequest.SendGetRequestAndParseJsonAsync<GPhotosDetailsFiles> ($"api/GoogleAccess/GetPhotosWithPicker/{sessionId}", httpClient);
                if (result.IsSuccessful)
                {
                    MediaItems = result?.Value;
                }
                else
                {
                    Error = result.Error;
                    _logger.LogWarning (result.Error);
                }
            }
            _logger.LogInformation ($"Exiting PollRequest at {DateTime.UtcNow.ToShortTimeString ()}");
            StateHasChanged ();
        }
        catch (Exception ex)
        {
            Error = "Something went wrong.";
            _logger.LogWarning(ex, $"Error in PollRequestPickerSession session: {sessionId}");    

        }
    }

    private async Task DownloadFiles(IEnumerable<PickedMediaItem> fileDetails) 
    {
        if (fileDetails?.Any () != true)
        {
            Error = "No files to download";
            return;
        }

        foreach (var file in fileDetails)
        {
            if (file?.MediaFile != null)
            {
                await DownloadFotoAsync (file.MediaFile);
            }
        }
    }

    // Downloads file from data stream. Tested only with photos
    private async Task DownloadFotoAsync(MediaFile fileDetails) 
    {
        _logger.LogInformation($"Running DownloadFotoAsync at {DateTime.UtcNow.ToShortTimeString()}");
        if (fileDetails is null)
        {
            Error = "Invalid file details.";
            return;
        }
        try
        {
            using (var httpClient = _factory.CreateClient ("GoogleAccess"))
            {
                httpClient.BaseAddress = new Uri (Options.ApiUrl);

                var response = await httpClient.GetAsync ($"api/GoogleAccess/downloadfoto/{HttpUtility.UrlEncode (fileDetails.BaseUrl)}/{HttpUtility.UrlEncode (fileDetails.MimeType)}");           //{HttpUtility.UrlEncode(url)}");
                if (response.IsSuccessStatusCode)
                {
                    var stream = await response.Content.ReadAsStreamAsync ();
                    using var streamRef = new DotNetStreamReference (stream: stream);

                    await JSRuntime.InvokeVoidAsync ("downloadFileFromStream", $"{fileDetails.Filename}", streamRef);
                }
                else
                {
                    Error = "Failed to download file.";
                    _logger.LogWarning ($"Failed to download file: {fileDetails.Filename} : {response.StatusCode}");
                }
            }
        } catch (Exception ex)
        {
            Error = "Something went wrong.";
            _logger.LogWarning (ex, $"Failed to download file {fileDetails.Filename}");
        }
    }

    private async Task DeleteMessageAsync(string messageId) 
    {
        _logger.LogInformation($"Running DeleteMail - deleting mail message with ID: {messageId}");
        if (string.IsNullOrEmpty (messageId))
        {
            Error = "Invalid message id.";
            return;
        }
        try
        {
            using (var httpClient = _factory.CreateClient ("GoogleAccess"))
            {
                httpClient.BaseAddress = new Uri (Options.ApiUrl);

                var result = await httpClient.PostAsJsonAsync ($"/api/GoogleAccess/deletemessage", messageId);
                if (result.IsSuccessStatusCode)
                {
                    IsSuccessfull = true;
                    await GetMailMessagesAsync ();
                    StateHasChanged ();
                }
                else
                {
                    Error = await result.Content.ReadAsStringAsync ();
                    _logger.LogWarning ($"Failed to delete message {messageId} {Error}");
                }
            }
        }
        catch (Exception ex)
        {
            Error = "Failed to delete message.";
            _logger.LogWarning (ex, $"Failed to delete message {messageId}");
        }
    }
}