@using Microsoft.AspNetCore.Http
@using System.Web
@using Newtonsoft.Json
@using global::GoogleAccess.Domain.Models
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Authentication
@using System.Text.Json
@using Models
@using Microsoft.AspNetCore.Identity;
@using Data
@using Google.Apis.Gmail.v1.Data

@page "/GoogleAccess"

@rendermode @(new InteractiveServerRenderMode(prerender:false))

@inject IJSRuntime JSRuntime;
@inject ILogger<GoogleStuff> _logger;
@inject IHttpClientFactory _factory;
@inject NavigationManager _navManager;
@inject AuthenticationStateProvider _authStateProvider;
@inject IHttpContextAccessor _httpContextAccessor;
@inject UserManager<ApplicationUser> UserManager;
@inject Blazored.SessionStorage.ISessionStorageService _storage;

<AuthorizeView>
    <div class="container">
      <CollapsingElement Title="Google Photos API">
        <ElementBody>
            <div class="row">
                <div class="col-md-2">
                    @*Closing the window before picking the fotos will have the polling loop run indefinately*@
                    <button @onclick="OpenTabAndPollSession">Pick Photos</button>
                </div>
            </div>
                    
            @if (MediaItems is not null && MediaItems.MediaItems.Count() > 0)
            {
                foreach (var item in MediaItems.MediaItems)
                {
                    <div class="row">
                        <div class="col-md-2">

                            <button class="btn btn-link" @onclick="@(async () => await DownloadFoto(item.MediaFile))">@item.MediaFile.Filename</button>
                        </div>
                    </div>
                }
                <div class="row">
                    <div class="col-md-2">
                        <button @onclick="(async ()=> await DownloadFiles(MediaItems.MediaItems))">Download files</button>

                    </div>
                </div>
            } 
        </ElementBody>
     </CollapsingElement>

  <CollapsingElement Title="Google Gmail API">
      <ElementBody>
                    @if (Messages is not null && Messages.Count() > 0)
                    {
                        foreach (var item in Messages)
                        {
                        <div class="row">
                            <div class="col-lg-6">
                                <p>@item.Payload?.Headers.Where(x => x.Name == "From").First().Value</p>
                                <button class="btn btn-link">@item.Payload?.Headers.Where(x => x.Name == "Subject").First().Value</button>
                            </div>
                            <div class="col-md-2">
                                <button class="btn btn-link">Delete mail</button>

                            </div>
                        </div>
                        }
                    }

      </ElementBody>
  </CollapsingElement>
</div>


</AuthorizeView>

@if (!String.IsNullOrEmpty(Error))
{
    <div class="alert alert-danger">@((MarkupString)Error) </div>
}
@* Suggested way of downloading files < 250 MB in size using JSInterop *@
<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
    const arrayBuffer = await contentStreamReference.arrayBuffer();
    const blob = new Blob([arrayBuffer]);
    const url = URL.createObjectURL(blob);

    const anchorElement = document.createElement('a');
    anchorElement.href = url;
    anchorElement.download = fileName ?? '';
    anchorElement.click();
    anchorElement.remove();
    URL.revokeObjectURL(url);
    };
</script>
@code
{
    private string? Error { get; set; }

    private CancellationToken token = new();

    [Parameter]
    public PickingSession? SessionData { get; set; }

    [Parameter]
    public string? AccessToken { get; set; }

    private GPhotosDetailsFiles? MediaItems { get; set; }

    private IEnumerable<Message> Messages { get; set; }

    // Checking wether user is authenticated. If so, we assume there is a access token to request a Picker session - this is not always the case
    protected override async Task OnInitializedAsync()
    {
        _logger.LogInformation("-- OnInitialized called --");
        if (_httpContextAccessor?.HttpContext?.User?.Identity?.IsAuthenticated == true)
        {
            await GetPickerSession();
            await GetMailMessages();
        }
        else 
        {
            Error = "Not authorized. Please log in with GoogleOpenIdConnect  <a href='/Account/Login'>Here</a>";
        }
    }

    protected override void OnParametersSet()
    {
        _logger.LogInformation("++ OnParametersSet called ++");
    }

    protected override void OnAfterRender(bool firstRender)
    {
        _logger.LogInformation($"** OnAfterRender called with firstrender = {firstRender} **");
    }
    private async Task GetMailMessages()
    {
        var httpClient = new HttpClient(new CustomAuthDelegatingHandler(_httpContextAccessor, UserManager));
        httpClient.BaseAddress = new Uri(ConfigData.httpClientURI);

        var response = await httpClient.GetAsync("/api/GoogleAccess/GetMessages");
        if (response.IsSuccessStatusCode)
        {
            Messages = JsonConvert.DeserializeObject<IList<Message>>(await response.Content.ReadAsStringAsync());
        }
        else
        {
            var content = await response.Content.ReadAsStringAsync();
            if (!String.IsNullOrEmpty(content))
            {
                Error = content;
            }
            else
            {
                Error = "Something went wrong.";
            }
        }
    }
    // Requesting the Picker session
    private async Task GetPickerSession()
    {
        var httpClient = new HttpClient(new CustomAuthDelegatingHandler(_httpContextAccessor, UserManager));
        httpClient.BaseAddress = new Uri(ConfigData.httpClientURI);

        var result = await httpClient.GetAsync("/api/GoogleAccess/GetPickerLink");
        if (result.IsSuccessStatusCode)
        {
            SessionData = await System.Text.Json.JsonSerializer.DeserializeAsync<PickingSession>(await result.Content?.ReadAsStreamAsync());
        }
        else
        {
            var content = await result.Content.ReadAsStringAsync();
            if (!String.IsNullOrEmpty(content))
            {
                Error = content;
            }
            else
            {
                Error = "Something went wrong.";
            }
        }
    }
    // Method that opens the picker session in a new tab and starts a Web API call for polling the session
    private async Task OpenTabAndPollSession()
    {
        if (SessionData is not null)
        {
            await JSRuntime.InvokeVoidAsync("open", $"{SessionData.pickerUri}", "_blank");
            await PollRequestPickerApi(SessionData.id);
        }
    }

    // Calling the API method that polls the photo Picker session and returns the details of the picked media files
    private async Task PollRequestPickerApi(string sessionId)
    {
        _logger.LogInformation($"Running PollRequest at {DateTime.UtcNow.ToShortTimeString()}");

        using (var client = new HttpClient(new CustomAuthDelegatingHandler(_httpContextAccessor, UserManager)))
        {
            client.BaseAddress = new Uri(ConfigData.httpClientURI);
            var response = await client.GetAsync($"api/GoogleAccess/GetPhotosWithPicker/{sessionId}");
            if (response.IsSuccessStatusCode)
            {
                MediaItems = await System.Text.Json.JsonSerializer.DeserializeAsync<GPhotosDetailsFiles>(await response.Content?.ReadAsStreamAsync());
            }
            else
            {
                var content = await response.Content.ReadAsStringAsync();
                if (!String.IsNullOrEmpty(content))
                {
                    Error = content;
                }
                else
                {
                    Error = "Something went wrong.";
                };
            }
        }
        _logger.LogInformation($"Exiting PollRequest at {DateTime.UtcNow.ToShortTimeString()}");
        StateHasChanged();
    }
    private async Task DownloadFiles(IEnumerable<PickedMediaItem> fileDetails) 
    {
        foreach (var file in fileDetails) 
        {
            await DownloadFoto(file.MediaFile);
        }
    }
    // Method that returns an API data stream for the clicked file. Tested only with fotos
    private async Task DownloadFoto(MediaFile fileDetails) 
    { 
        _logger.LogInformation($"Running DownloadFoto at {DateTime.UtcNow.ToShortTimeString()}");
        using (var client = new HttpClient(new CustomAuthDelegatingHandler(_httpContextAccessor, UserManager))) {
            client.BaseAddress = new Uri(ConfigData.httpClientURI);

            var response = await client.GetAsync($"api/GoogleAccess/downloadfoto/{HttpUtility.UrlEncode(fileDetails.BaseUrl)}/{HttpUtility.UrlEncode(fileDetails.MimeType)}");           //{HttpUtility.UrlEncode(url)}");
            if (response.IsSuccessStatusCode) 
            {
                var stream = await response.Content.ReadAsStreamAsync();
                using var streamRef = new DotNetStreamReference(stream: stream);

                await JSRuntime.InvokeVoidAsync("downloadFileFromStream", $"{fileDetails.Filename}", streamRef);
            }
            else
            {
                Error = "Failed to download file.";
            }
        }
    }
}